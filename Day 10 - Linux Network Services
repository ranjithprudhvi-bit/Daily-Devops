Our monitoring tool has reported an issue in Stratos Datacenter. One of our app servers has an issue, as its Apache service is not reachable on port 6100 (which is the Apache port). The service itself could be down, the firewall could be at fault, or something else could be causing the issue. Use tools like telnet, netstat, etc. to find and fix the issue. Also make sure Apache is reachable from the jump host without compromising any security settings. Once fixed, you can test the same using command curl http://stapp01:6100 command from jump host. Note: Please do not try to alter the existing index.html code, as it will lead to task failure.

Issue: Apache Service Not Reachable on Custom Port (6100)

1️⃣ Background Knowledge (Why This Task Matters)

In enterprise Linux environments:

Application servers often run services on non-standard ports

Monitoring tools detect issues like:

Service unreachable

Health check failures

A service being “running” does not guarantee accessibility

Troubleshooting must follow a layered approach:

Service status

Port binding

Firewall rules

Network reachability

This task simulated a real production incident where Apache was expected to be reachable from a jump host on port 6100, but was not.

2️⃣ Initial Problem Statement

Apache service was expected to be reachable on:

http://stapp01:6100


Monitoring reported Apache as unreachable

Curl from jump host failed:

No route to host

3️⃣ Mistakes Made During the Task (Important Learning)
❌ Mistake 1: Assuming Apache Being “Active” Means It Is Reachable

Observation:

systemctl status httpd


Apache showed:

Active: active (running)


Why this was misleading:

A service can run but:

Not bind to the correct port

Be blocked by firewall rules

✅ Learning:
Always verify port ownership, not just service status.

❌ Mistake 2: Not Checking Which Process Was Using Port 6100 Initially

What we found later:

netstat -tulnp | grep 6100


Output:

127.0.0.1:6100 LISTEN sendmail


Issue:

Port 6100 was already occupied

Apache could not bind to the port

Port was bound to 127.0.0.1 (localhost only)

✅ Learning:
Before blaming Apache or firewall, always check who owns the port.

❌ Mistake 3: Assuming firewalld Was in Use

We initially checked:

systemctl status firewalld


Result:

Unit firewalld.service could not be found


Reality:

System was using iptables (legacy)

Firewall rules were enforced at kernel level

✅ Learning:
Never assume firewall type — verify first.

❌ Mistake 4: Overlooking the REJECT Rule in iptables

Initial iptables state:

iptables -L -n -v


Key rule:

REJECT all -- reject-with icmp-host-prohibited


Impact:

Only SSH (22) was allowed

All other ports were explicitly rejected

This caused:

curl: No route to host


✅ Learning:
Rule order in iptables is critical — ACCEPT rules must come before REJECT.

4️⃣ Step-by-Step Solutions Applied (With Explanation)
✅ Step 1: Identify Port Ownership
netstat -tulnp | grep 6100


Why:

Confirms which service is listening

Identifies binding address

Finding:

sendmail was occupying port 6100

✅ Step 2: Stop Conflicting Service
systemctl stop sendmail
systemctl disable sendmail


Why:

Frees the required port

Prevents future conflicts after reboot

✅ Step 3: Verify Apache Configuration
grep -R "Listen" /etc/httpd


Why:

Confirms Apache is configured to listen on port 6100

Avoids unnecessary config changes

Result:

Listen 6100

✅ Step 4: Restart Apache to Rebind Port
systemctl restart httpd


Why restart (not reload):

Port binding changes require restart

Apache must reclaim the port

✅ Step 5: Confirm Apache Owns the Port
netstat -tulnp | grep 6100


Correct state:

0.0.0.0:6100 LISTEN httpd

✅ Step 6: Inspect iptables Firewall Rules
iptables -L -n -v


Finding:

Only SSH allowed

All other traffic rejected

✅ Step 7: Allow Port 6100 Securely
iptables -I INPUT -p tcp --dport 6100 -m state --state NEW -j ACCEPT


Why this is best practice:

Minimal change

No firewall flush

Maintains security posture

Allows only required traffic

✅ Step 8: Final Validation

From jump host:

curl http://stapp01:6100


Result:

Apache page returned successfully

5️⃣ Final Outcome
Item	Status
Apache service	✅ Running
Port binding	✅ Correct
Firewall	✅ Secure
External access	✅ Verified
Task status	✅ Successful
6️⃣ Key Takeaways (Very Important)

“No route to host” usually indicates firewall rejection

Service status alone is never enough

Always check:

Port ownership

Binding IP

Firewall rule order

Fix the root cause, not symptoms

Never disable security controls in production
